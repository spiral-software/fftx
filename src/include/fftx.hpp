
//  Copyright (c) 2018-2025, Carnegie Mellon University
//   All rights reserved.
//
//  See LICENSE file for full information

/*
    ___________________  __
   / ____/ ____/_  __/ |/ /
  / /_  / /_    / /  |   / 
 / __/ / __/   / /  /   |  
/_/   /_/     /_/  /_/|_|  
                           

*/

#ifndef FFTX_HEADER
#define FFTX_HEADER


#include <regex>
#include <memory>
#include <iostream>
#include <fstream>
#include <utility>
#include <vector>
#include <chrono>

#include <map>
#include <string>

#include <array>

#include <cassert>
#include <complex>
#include <iomanip>

#include "fftx_base_types.hpp"

/*! \file fftx.hpp */

/**
 * \mainpage FFTX C++ API Documentation
 *
 * This is the autogenerated reference documentation for the FFTX C++ interface,
 * built using Doxygen and Breathe with integration into the Sphinx documentation site.
 *
 * FFTX is a domain-specific system for generating high-performance FFT-based code
 * across multiple backends (CPU, GPU, SYCL, HIP, etc.).
 *
 * ### Contents:
 * - Core types: `point_t`, `box_t`, `array_t`, `global_ptr`
 * - Transform execution: `FFTXProblem`, `Executor`, and batch APIs
 * - Backend-specific options and integration notes
 *
 * \htmlonly
 * <p>Back to project website: <a href="https://spiral-software.github.io/fftx/">https://spiral-software.github.io/fftx/</a></p>
 * \endhtmlonly
 */

// Macros for stringizing:  do std::string(FFTX_XSTR(macroname)).
#define FFTX_XSTR(s) FFTX_STR(s)
#define FFTX_STR(s) #s

#define FFTX_VERSION 1.3.0

// Set this to 1 for row-major order, 0 for column-major order.
#define FFTX_ROW_MAJOR_ORDER 1

// Set this to 1 if truncating complex array in last dimension, 0 if in first.
#define FFTX_COMPLEX_TRUNC_LAST 1

namespace fftx
{
  inline std::string version() { return std::string(FFTX_XSTR(FFTX_VERSION)); }
  
  /** \relates fftx::array_t
      Applies the argument function to each element of the argument array,
      where the argument function <tt>f</tt> has the signature<br>
      <tt>void f(T& value, const fftx::point_t<DIM>& location)</tt>.

      The function argument is typically specified as a lambda expression, as in:
      \code{.cpp}
      fftx::array_t<DIM, T>& array;
      forall([varlist](T(&v), const fftx::point_t<DIM>& location)
      {
         // ... assignment of v, or operations or function calls on v
      }, array);
      \endcode
      which loops through <tt>array</tt> over its domain,
      with <tt>v</tt> as array element at index <tt>location</tt>
      to be either assigned or have operations or
      functions called on it,
      and <tt>varlist</tt> (which may be empty)
      is a comma-separated list of previously declared
      variables that are used within the block.
  */
  template<int DIM, typename T, typename Func>
  void forall(Func f, array_t<DIM, T>& array);

  /** \relates fftx::array_t
      Applies the argument function to each element of the
      two argument arrays,
      where the argument function <tt>f</tt> has the signature<br>
      <tt>void f(T1& value, const T2&, const point_t<DIM>& location)</tt>.

      The two arrays <tt>array</tt> and <tt>array2</tt> must
      have the same domain.

      The function argument is typically specified as a lambda expression, as in:
      \code{.cpp}
      fftx::array_t<DIM, T1>& array;
      const fftx::array_t<DIM, T2>& array2;
      forall([varlist](T1(&v), T2(&v2), const fftx::point_t<DIM>& location)
      {
         // ... assignment of v, or operations or function calls on v and v2
      }, array, array2);
      \endcode
      which loops through the common domain of <tt>array</tt> and <tt>array2</tt>,
      taking element <tt>v</tt> of <tt>array</tt>
      and element <tt>v2</tt> of <tt>array2</tt>
      at index <tt>location</tt>
      having operations or functions called on them
      and possibly assigning <tt>v</tt>,
      and <tt>varlist</tt> (which may be empty)
      is a comma-separated list of previously declared
      variables that are used within the block.
  */
  template<int DIM, typename T1, typename T2, typename Func>
  void forall(Func f, array_t<DIM, T1>& array, const array_t<DIM, T2>& array2);


  // component alias  Subselects outer-most dimension (the not contiguous one) 
  /** \internal */
  template<int DIM, typename T>
  array_t<DIM-1, T> nth(array_t<DIM, T>& array, int index)
  {
    box_t<DIM-1> b = array.m_domain.projectC();
    array_t<DIM-1, T> rtn(b);
    OutStream()<<"var_"<<(uint64_t)rtn.m_data.local()<<":=nth(var_"<<(uint64_t)array.m_data.local()<<","<<index<<");\n";
    return rtn;
  }

  /** \internal */
  template<int DIM, typename T>
  void copy(array_t<DIM, T>& dest, const array_t<DIM, T>& src)
  {
    OutStream()<<"    TDAGNode(TGath(fBox("<<src.m_domain.extents()<<")),var_"<<dest.id()<<", var_"<<src.id()<<"),\n";
  }

  /** \internal */
  inline void rawScript(const std::string& a_rawScript)
  {
    OutStream()<<"\n"<<a_rawScript<<"\n";
  }

  /** \internal */
  template <typename T>
  struct TypeName
  {
    static const char* Get()
    {
      return typeid(T).name();
    }
  };

// a specialization for each type of those you want to support
// and don't like the string returned by typeid
  /** \internal */
  template <>
  struct TypeName<double>
  {
    static const char* Get()
    {
      return "double";
    }
  };
  /** \internal */
  template <>
  struct TypeName<std::complex<double>>
  {
    static const char* Get()
    {
      return "std::complex<double>";
    }
  };
  
  /** \internal */
  template<typename T, std::size_t COUNT>
  inline std::ostream& operator<<(std::ostream& os, const std::array<T, COUNT>& arr)
  {
    os<<std::fixed<<std::setprecision(2);
    os<<"["<<arr[0];
    for(int i=1; i<COUNT; i++) os<<","<<arr[i];
    os<<"]";
    return os;
  }
  
  /** \internal */
  template<int DIM>
  void MDDFT(const point_t<DIM>& extents, int batch,
             array_t<DIM, std::complex<double>>& destination,
             array_t<DIM, std::complex<double>>& source)
  {
    OutStream()<<"   TDAGNode(TTensorI(MDDFT("<<extents<<",-1),"<<batch<<",APar, APar), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }
  
  /** \internal */
  template<int DIM>
  void IMDDFT(const point_t<DIM>& extents, int batch,
             array_t<DIM, std::complex<double>>& destination,
             array_t<DIM, std::complex<double>>& source)
  {
    OutStream()<<"   TDAGNode(TTensorI(MDDFT("<<extents<<",1),"<<batch<<",APar, APar), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }
    
  /** \internal */
  template<int DIM>
  void MDPRDFT(const point_t<DIM>& extent, int batch,
               array_t<DIM+1, double>& destination,
               array_t<DIM+1, double>& source)
  {
    OutStream()<<"    TDAGNode(TTensorI(MDPRDFT("<<extent<<",-1),"<<batch<<",APar,APar), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }

  /** \internal */
  template<int DIM>
  void IMDPRDFT(const point_t<DIM>& extent, int batch,
               array_t<DIM+1, double>& destination,
               array_t<DIM+1, double>& source)
  {
    OutStream()<<"    TDAGNode(TTensorI(IMDPRDFT("<<extent<<",1),"<<batch<<",APar,APar), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }

  /** \internal */
  template<int DIM>
  void PRDFT(const point_t<DIM>& extent,
             array_t<DIM, std::complex<double>>& destination,
             array_t<DIM, double>& source)
  {
    OutStream()<<"    TDAGNode(MDPRDFT("<<extent<<",-1), var_"<<destination.id()<<",var_"<<source.id()<<"),\n"; // FIXME: was 1, not -1.
  }

  /** \internal */
  template<int DIM>
  void IPRDFT(const point_t<DIM>& extent,
              array_t<DIM, double>& destination,
              array_t<DIM, std::complex<double>>& source)
  {
    OutStream()<<"    TDAGNode(IMDPRDFT("<<extent<<",1), var_"<<destination.id()<<",var_"<<source.id()<<"),\n"; // FIXME: was -1, not 1.
  }

  /** \internal */
  template<int DIM>
  void kernel(const array_t<DIM, double>& symbol,
              array_t<DIM, std::complex<double>>& destination,
              const array_t<DIM, std::complex<double>>& source)
  {
    OutStream()<<"    TDAGNode(Diag(diagTensor(FDataOfs(symvar,"<<symbol.m_domain.size()<<",0),fConst(TReal, 2, 1))), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }

  /** \internal */
  template<int DIM>
  void kernel(const array_t<DIM, std::complex<double>>& symbol,
              array_t<DIM, std::complex<double>>& destination,
              const array_t<DIM, std::complex<double>>& source)
  {
    OutStream()<<"    TDAGNode(RCDiag(FDataOfs(symvar,"<<2*symbol.m_domain.size()<<",0)), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }

  /** \internal */
  inline void include(const char* includeFile)
  {
    OutStream()<<"opts.includes:=opts.includes::["<<includeFile<<"];\n";
  }

  /** \internal */
  template<int DIM, typename T>
  void zeroEmbedBox(array_t<DIM, T>& destination, const array_t<DIM, T>& source)
  {
    OutStream()<<"    TDAGNode(ZeroEmbedBox("<<destination.m_domain.extents()<<",[";
    for(int i=0; i<DIM; i++)
      {
        OutStream()<<"["<<source.m_domain.lo[i]<<".."<<source.m_domain.hi[i]<<"]";
        if(i<DIM-1) OutStream()<<",";
      }
    OutStream()<<"]), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }

  /** \internal */
  template<int DIM, typename T>
  void extractBox(array_t<DIM, T>& destination, const array_t<DIM, T>& source)
  {
    OutStream()<<"    TDAGNode(ExtractBox("<<source.m_domain.extents()<<",[";
    for(int i=0; i<DIM; i++)
      {
        OutStream()<<"["<<destination.m_domain.lo[i]<<".."<<destination.m_domain.hi[i]<<"]";
        if(i<DIM-1) OutStream()<<",";
      }
    OutStream()<<"]), var_"<<destination.id()<<",var_"<<source.id()<<"),\n";
  }
  
  /** \internal */
  static std::string inputType = "double";
  /** \internal */
  static int inputCount = 1;
  /** \internal */
  static std::string outputType = "double";
  /** \internal */
  static int outputCount = 1;

  /** \internal */
  template<int DIM, typename T, std::size_t COUNT>
  void setInputs(const std::array<array_t<DIM, T>, COUNT>& a_inputs)
  {
    inputType = TypeName<T>::Get();
    for(int i=0; i<COUNT; i++)
      {
        OutStream()<<"var_"<<a_inputs[i].id()<<":= nth(X,"<<i<<");\n";
      }
  }
  /** \internal */
  template<int DIM, typename T>
  void setInputs(const array_t<DIM, T>& a_inputs)
  {
    inputType = TypeName<T>::Get();
    OutStream()<<"var_"<<a_inputs.id()<<":= X;\n";
  }
  
  /** \internal */
  template<int DIM, typename T, std::size_t COUNT>
  void setOutputs(const std::array<array_t<DIM, T>, COUNT>& a_outputs)
  {
    outputType = TypeName<T>::Get();
    for(int i=0; i<COUNT; i++)
      {
        OutStream()<<"var_"<<a_outputs[i].id()<<":= nth(Y,"<<i<<");\n";
      }
  }
  /** \internal */
  template<int DIM, typename T>
  void setOutputs(const array_t<DIM, T>& a_outputs)
  {
    outputType = TypeName<T>::Get();
    OutStream()<<"var_"<<a_outputs.id()<<":= Y;\n";
  }

  /** \internal */
  template<int DIM, typename T, std::size_t COUNT>
  void setSymbol(const  std::array<array_t<DIM, T>, COUNT>& a_symbol)
  {
    OutStream()<<"symvar := var(\"sym\", TPtr(TPtr(TReal)));\n";
  }
  
  /** \internal */
  template<int DIM, typename T>
  void resample(const std::array<double, DIM>& shift,
                array_t<DIM,T>& destination,
                const array_t<DIM,T>& source)
  {
    OutStream()<<"    TDAGNode(TResample("
             <<destination.m_domain.extents()<<","
             <<source.m_domain.extents()<<","<<shift<<"),"
             <<"var_"<<destination.id()<<","
             <<"var_"<<source.id()<<"),\n";
  }
  /** \internal */
  inline void openDAG()
  {
  //  OutStream()<<"conf := FFTXGlobals.defaultWarpXConf();\n";
  //  OutStream()<<"opts := FFTXGlobals.getOpts(conf);\n";                                     
  //  OutStream()<<"symvar := var(\"sym\", TPtr(TPtr(TReal)));\n";
    OutStream()<<"transform:= TFCall(TDecl(TDAG([\n";
  }

  /** \internal */
  inline void openScalarDAG()
  {
    OutStream()<<"symvar := var(\"sym\", TPtr(TReal));\n";
    OutStream()<<"transform:= TFCall(TDecl(TDAG([\n";
  }
  
 
 
  /** \internal */
  template<typename T, int DIM, unsigned long COUNT>
  void closeDAG(std::array<array_t<DIM,T>, COUNT>& localVars, const char* name)
  {
    static const char* header_template = R"(

    #ifndef FFTX_PLAN_CODEGEN_H
    #define FFTX_PLAN_CODEGEN_H

    #include "fftx.hpp"

    extern void init_PLAN_spiral(); 
    extern void PLAN_spiral(double** Y, double** X, double** symvar); 
    extern void destroy_PLAN_spiral();

   namespace PLAN
   {
    inline void init(){ init_PLAN_spiral();}
    inline void trace();
    template<std::size_t IN_DIM, std::size_t OUT_DIM, std::size_t S_DIM>
    inline fftx::handle_t transform(std::array<fftx::array_t<DD, S_TYPE>,IN_DIM>& source,
                                    std::array<fftx::array_t<DD, D_TYPE>,OUT_DIM>& destination,
                                    std::array<fftx::array_t<DD, double>,S_DIM>& symvar)
    {   // for the moment, the function signature is hard-coded.  trace will
      // generate this in our better world
        double* input[IN_DIM];
        double* output[OUT_DIM];
        double* sym[S_DIM];
        for(int i=0; i<IN_DIM; i++) input[i] = (double*)(source[i].m_data.local());
        for(int i=0; i<OUT_DIM; i++) output[i] = (double*)(destination[i].m_data.local());
        for(int i=0; i<S_DIM; i++) sym[i] = (double*)(symvar[i].m_data.local());

        PLAN_spiral(output, input, sym);
   
    // dummy return handle for now
      fftx::handle_t rtn;
      return rtn;
    }

    template<std::size_t IN_DIM, std::size_t OUT_DIM>
    inline fftx::handle_t transform(std::array<fftx::array_t<DD, S_TYPE>,IN_DIM>& source,
                                    std::array<fftx::array_t<DD, D_TYPE>,OUT_DIM>& destination)
    {   // for the moment, the function signature is hard-coded.  trace will
      // generate this in our better world
        double* input[IN_DIM];
        double* output[OUT_DIM];
        double** sym=nullptr;
        for(int i=0; i<IN_DIM; i++) input[i] = (double*)(source[i].m_data.local());
        for(int i=0; i<OUT_DIM; i++) output[i] = (double*)(destination[i].m_data.local());
  

        PLAN_spiral(output, input, sym);
   
    // dummy return handle for now
      fftx::handle_t rtn;
      return rtn;
    }
    //inline void destroy(){ destroy_PLAN_spiral();}
    inline void destroy(){ }
  };

 #endif  )";
   
   tracing = false;
   std::string headerName = std::string(name)+std::string(".fftx.codegen.hpp");
   std::ofstream headerFile(headerName);
   //DataTypeT<SOURCE> s;
   //DataTypeT<DEST> d;
   std::string header_text(header_template);
   header_text = std::regex_replace(header_text, std::regex("PLAN"),std::string(name));
   header_text = std::regex_replace(header_text, std::regex("S_TYPE"), inputType);
   header_text = std::regex_replace(header_text, std::regex("D_TYPE"), outputType);
   header_text = std::regex_replace(header_text, std::regex("DD"), std::to_string(DIM-1));
   
   headerFile<<header_text<<"\n";
   headerFile.close();
   
   OutStream()<<"\n]),\n   [";
   if(COUNT==0)
     {}
   else
     {
      OutStream()<<"var_"<<(uint64_t)localVars[0].m_data.local();
      for(int i=1; i<COUNT; i++) OutStream()<<", var_"<<(uint64_t)localVars[i].m_data.local();
     }
     OutStream()<<"]\n),\n";
     OutStream()<<"rec(XType:= TPtr(TPtr(TReal)), YType:=TPtr(TPtr(TReal)), fname:=\""<<name<<"_spiral\", params:= [symvar])\n"
              <<");\n";
     OutStream()<<"prefix:=\""<<name<<"\";\n";
  }

  /** \internal */
  template<typename T, int DIM, std::size_t COUNT>
  std::string varNames(const std::array<array_t<DIM,T>, COUNT>& a_vars)
  {
   std::string rtn;
   for(int i=0; i<COUNT; i++)
      {
        rtn +="var_";
        rtn += std::to_string((uint64_t)a_vars[i].m_data.local());
        if(i+1<COUNT) rtn +=",";
      }
    return rtn;
  }
  
  /** \internal */
template<int DIM>
  void closeScalarDAG(std::string localVarNames, const char* name)
  {
    static const char* header_template = R"(

    #ifndef FFTX_PLAN_CODEGEN_H
    #define FFTX_PLAN_CODEGEN_H

    #include "fftx.hpp"

    extern void init_PLAN_spiral(); 
    extern void PLAN_spiral(double* Y, double* X, double* symvar); 
    extern void destroy_PLAN_spiral();

   namespace PLAN
   {
    double CPU_milliseconds=0;
    float  GPU_milliseconds=0;
#ifdef __CUDACC__
    cudaEvent_t start, stop;
    void kernelStart() {cudaEventRecord(start);}
    void kernelStop()
    {
     cudaEventRecord(stop);
     cudaDeviceSynchronize();
     cudaEventSynchronize(stop);
     cudaEventElapsedTime(&GPU_milliseconds, start, stop);
    }
#else
    void kernelStart(){ }
    void kernelStop(){ }
#endif
    inline void init(){ 
          init_PLAN_spiral();
#ifdef __CUDACC__
         cudaEventCreate(&start);
         cudaEventCreate(&stop);
#endif
           }
    inline void trace();
    inline fftx::handle_t transform(fftx::array_t<DD, S_TYPE>& source,
                                    fftx::array_t<DD, D_TYPE>& destination,
                                    fftx::array_t<DD, double>& symvar)
    {   // for the moment, the function signature is hard-coded.  trace will
      // generate this in our better world
        double* input;
        double* output;
        double* sym;
        input = (double*)(source.m_data.local());
        output = (double*)(destination.m_data.local());
        sym = (double*)(symvar.m_data.local());

        kernelStart();
        std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
           PLAN_spiral(output, input, sym);
        kernelStop();
        std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>>(t2-t1);
        CPU_milliseconds = time_span.count()*1000;
    // dummy return handle for now
      fftx::handle_t rtn;
      return rtn;
    }

 
    inline fftx::handle_t transform(fftx::array_t<DD, S_TYPE>& source,
                                    fftx::array_t<DD, D_TYPE>& destination)
    {   // for the moment, the function signature is hard-coded.  trace will
      // generate this in our better world
        double* input;
        double* output;
        double* sym=nullptr;
        input = (double*)(source.m_data.local());
        output = (double*)(destination.m_data.local());
  
        kernelStart();
        std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
           PLAN_spiral(output, input, sym);
        kernelStop();
        std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>>(t2-t1);
        CPU_milliseconds = time_span.count()*1000;

    // dummy return handle for now
      fftx::handle_t rtn;
      return rtn;
    }
    //inline void destroy(){ destroy_PLAN_spiral();}
    inline void destroy(){ }
  };

 #endif  )";

   tracing = false;
   std::string headerName = std::string(name)+std::string(".fftx.codegen.hpp");
   std::ofstream headerFile(headerName);
   //DataTypeT<SOURCE> s;
   //DataTypeT<DEST> d;
   std::string header_text(header_template);
   header_text = std::regex_replace(header_text,std::regex("PLAN"),std::string(name));
   header_text = std::regex_replace(header_text, std::regex("S_TYPE"), inputType);
   header_text = std::regex_replace(header_text, std::regex("D_TYPE"), outputType);
   header_text = std::regex_replace(header_text, std::regex("DD"), std::to_string(DIM));
#ifdef FFTX_HIP
   header_text = std::regex_replace(header_text,std::regex("cuda"),std::string("hip"));
   header_text = std::regex_replace(header_text,std::regex("__CUDACC__"),std::string("__HIPCC__"));
   header_text = std::string("#include <hip/hip_runtime.h>\n\n") + header_text;
#endif
   headerFile<<header_text<<"\n";
   headerFile.close();

   OutStream()<<"\n]),\n   [";
    // if(COUNT==0){}
    // else
    //   {
    //     OutStream()<<"var_"<<(uint64_t)localVars[0].m_data.local();
    //     for(int i=1; i<COUNT; i++) OutStream()<<", var_"<<(uint64_t)localVars[i].m_data.local();
    //   }
   OutStream() <<localVarNames;
   OutStream()<<"]\n),\n";
   OutStream()<<"rec(fname:=\""<<name<<"_spiral\", params:= [symvar])\n"
            <<");\n";
   OutStream()<<"prefix:=\""<<name<<"\";\n";
} 
 
 
  /** \internal */
    template<typename T, int DIM, std::size_t COUNT>
  void closeScalarDAG(const std::array<array_t<DIM,T>, COUNT>& a_vars, const char* name)
  {
    closeScalarDAG<DIM>(varNames(a_vars), name);
  }

  /** \internal */
    template<typename T, typename T2, int DIM, std::size_t COUNT, std::size_t COUNT2>
  void closeScalarDAG(const std::array<array_t<DIM,T>, COUNT>& a_vars,
                      const std::array<array_t<DIM,T2>, COUNT2>& a_vars2, const char* name)
  {

    closeScalarDAG<DIM>(varNames(a_vars)+','+varNames(a_vars2), name);

  }

/** \relates fftx::box_t
    Returns true if the given <tt>point_t</tt> is contained in the given <tt>box_t</tt>.
*/
  template<int DIM>
  inline bool isInBox(point_t<DIM> a_pt, const box_t<DIM>& a_bx)
  {
    point_t<DIM> lo = a_bx.lo;
    point_t<DIM> hi = a_bx.hi;
    for (int d = 0; d < DIM; d++)
      {
        if (a_pt[d] < lo[d]) return false;
        if (a_pt[d] > hi[d]) return false;
      }
    return true;
  }

/** \relates fftx::box_t
    Returns the position of
    the given <tt>point_t</tt> within the given <tt>box_t</tt>
    according to the ordering of points within it, starting from 0.

    This function is the inverse of <tt>pointFromPositionBox()</tt>
    on the same <tt>box_t</tt>.
 */
  template<int DIM>
  inline size_t positionInBox(point_t<DIM> a_pt, const box_t<DIM>& a_bx)
  {
    point_t<DIM> lo = a_bx.lo;
    point_t<DIM> lengths = a_bx.extents();

#if FFTX_ROW_MAJOR_ORDER
    // Row-major order: Last dimension changes fastest.
    size_t disp = a_pt[0] - lo[0];
    for (int d = 1; d < DIM; d++)
      {
        disp *= lengths[d];
        disp += a_pt[d] - lo[d];
      }
#else
    // Column-major order: First dimension changes fastest.
    size_t disp = a_pt[DIM-1] - lo[DIM-1];
    for (int d = DIM-2; d >= 0; d--)
      {
        disp *= lengths[d];
        disp += a_pt[d] - lo[d];
      }
#endif

    return disp;
  }

/** \relates fftx::box_t
    Returns the <tt>point_t</tt> that is at the given position
    in the given <tt>box_t</tt>,
    according to the ordering of points within it, starting from 0.

    This function is the inverse of <tt>positionInBox()</tt>
    on the same <tt>box_t</tt>.
 */
  template<int DIM>
  inline point_t<DIM> pointFromPositionBox(size_t a_ind, const box_t<DIM>& a_bx)
  {
    point_t<DIM> lo = a_bx.lo;
    point_t<DIM> lengths = a_bx.extents();

    point_t<DIM> pt;

#if FFTX_ROW_MAJOR_ORDER
    // Row-major order: Last dimension changes fastest.
    size_t disp = a_ind;
    for (int d = DIM-1; d >= 0; d--)
       {
          pt[d] = lo[d] + disp % lengths[d];
          disp = (disp - (pt[d] - lo[d])) / lengths[d];
       }
#else
    // Column-major order: First dimension changes fastest.
    size_t disp = a_ind;
    for (int d = 0; d < DIM; d++)
       {
          pt[d] = lo[d] + disp % lengths[d];
          disp = (disp - (pt[d] - lo[d])) / lengths[d];
       }
#endif

    return pt;
  }

 
  // helper meta functions===============
  /** \internal */
  template<int DIM>
  void projecti(int out[], const int in[] );

  /** \internal */
  template<>
  inline void projecti<0>(int out[], const int in[]) { return; }

  /** \internal */
  template<int DIM>
  inline void projecti(int out[], const int in[] )
  {
    out[DIM-1]=in[DIM-1]; projecti<DIM-1>(out, in);
  }

  /** \internal */
  template<int DIM>
  std::size_t bsize(int const lo[], int const hi[]);
  /** \internal */
  template<>
  inline std::size_t bsize<0>(int const lo[], int const hi[]){return 1;}
  /** \internal */
  template<int DIM>
  inline std::size_t bsize(int const lo[], int const hi[]){ return (hi[DIM-1]-lo[DIM-1]+1)*bsize<DIM-1>(lo, hi);}

  /** \internal */
  template<int DIM>
  inline int point_t<DIM>::product()
  {
    int prod = 1;
    for (int d = 0; d < DIM; d++)
      {
        prod *= x[d];
      }
    return prod;
  }
    
  /** \internal */
  template<int DIM>
  inline point_t<DIM-1> point_t<DIM>::project() const
  {
    point_t<DIM-1> rtn;
    projecti<DIM-1>(rtn.x, x);
    return rtn;
  }

  /** \internal */
  template<int DIM>
  inline point_t<DIM-1> point_t<DIM>::projectC() const
  {
    point_t<DIM-1> rtn;
    for(int i=0; i<DIM-1; i++) rtn[i] = x[i+1];
    return rtn;
  }
  
  /** \internal */
  template<unsigned char DIM>
  inline bool equalInts(const int* a, const int* b) { return (a[DIM-1]==b[DIM-1])&&equalInts<DIM-1>(a, b);}
  /** \internal */
  template<>
  inline bool equalInts<0>(const int* a, const int* b) {return true;}
  
  /** \internal */
  template<int DIM>
  inline std::size_t box_t<DIM>::size() const { return bsize<DIM>(lo.x,hi.x);}

  /** \internal */
  template<int DIM>
  inline bool point_t<DIM>::operator==(const point_t<DIM>& a_rhs) const
  {
    return equalInts<DIM>(x, a_rhs.x);
  }
  
  /** \internal */
  template<int DIM>
  inline void point_t<DIM>::operator=(int a_value)
  {
    for(int i=0; i<DIM; i++) x[i]=a_value;
  }

  /** \internal */
  template<int DIM>
  inline point_t<DIM> point_t<DIM>::operator*(int a_scale) const
  {
    point_t<DIM> rtn(*this);
    for(int i=0; i<DIM; i++) rtn.x[i]*=a_scale;
    return rtn;
  }

  /** \internal */
  template<int DIM>
  inline point_t<DIM> point_t<DIM>::Unit()
  {
    point_t<DIM> rtn;
    for(int i=0; i<DIM; i++) rtn.x[i]=1;
    return rtn;
  }

  /** \internal */
  template<int DIM>
  inline point_t<DIM> point_t<DIM>::Zero()
  {
    point_t<DIM> rtn;
    for(int i=0; i<DIM; i++) rtn.x[i]=0;
    return rtn;
  } 
  
  /** \internal */
  template<int DIM, typename T, typename Func_P>
  struct forallHelper
  {
    static void f(T*& __restrict ptr, int* pvect, int* lo, int* hi, Func_P fp)
    {
      for(int i=lo[DIM-1]; i<=hi[DIM-1]; ++i)
        {
          pvect[DIM-1]=i;
          forallHelper<DIM-1, T, Func_P>::f(ptr, pvect, lo, hi, fp);
        }
    }
    template<typename T2>
    static void f2(T*& __restrict ptr1, const T2*& __restrict ptr2, int* pvect, int* lo, int* hi, Func_P fp)
    {
      for(int i=lo[DIM-1]; i<=hi[DIM-1]; ++i)
        {
          pvect[DIM-1]=i;
          forallHelper<DIM-1, T, Func_P>::f2(ptr1, ptr2, pvect, lo, hi, fp);
        }
    }
  };
  
  /** \internal */
  template<typename T, typename Func_P>
  struct forallHelper<1, T, Func_P>
  {
    static void f(T*& __restrict ptr, int* pvect, int* lo, int* hi, Func_P fp)
    {
      for(int i=lo[0]; i<=hi[0]; i++, ptr++)
        {
          pvect[0]=i;
          fp(*ptr);
        }
    }
    template<typename T2>
    static void f2(T*& __restrict ptr1,  const T2*& __restrict ptr2, int* pvect, int* lo, int* hi, Func_P fp)
    {
      for(int i=lo[0]; i<=hi[0]; i++, ptr1++, ptr2++)
        {
          pvect[0]=i;
          fp(*ptr1, *ptr2);
        }
    }
 
  };
  
  /** \internal */
  template<int DIM, typename T, typename Func>
  inline void forall(Func f, array_t<DIM, T>& array)
  {
    int* lo=array.m_domain.lo.x;
    int* hi=array.m_domain.hi.x;
    point_t<DIM> p = array.m_domain.lo;
    auto fp = [&](T& v){f(v, p);};
    T* ptr = array.m_data.local();
    forallHelper<DIM, T,decltype(fp) >::f(ptr, p.x, lo, hi,fp);
  }
  /** \internal */
  template<int DIM, typename T1, typename T2, typename Func>
  inline void forall(Func f, array_t<DIM, T1>& array, const array_t<DIM, T2>& array2)
  {
    int* lo=array.m_domain.lo.x;
    int* hi=array.m_domain.hi.x;
    point_t<DIM> p = array.m_domain.lo;
    auto fp = [&](T1& v, const T2& v2){f(v, v2, p);};
    T1* ptr = array.m_data.local();
    const T2* ptr2 = array2.m_data.local();
    forallHelper<DIM, T1,decltype(fp) >::f2(ptr, ptr2, p.x, lo, hi,fp);
  }
     
  /** \internal */
  template<unsigned char DIM>
  inline size_t dimHelper(int* lo, int* hi) {return (hi[DIM-1]-lo[DIM-1]+1)*dimHelper<DIM-1>(lo, hi);}
  /** \internal */
  template<>
  inline size_t dimHelper<0>(int* lo, int* hi){ return 1;}
  
  /** \internal */
  template<int DIM>
  inline std::size_t normalization(box_t<DIM> a_transformBox)
  {
    //return dimHelper<DIM>(a_transformBox.lo.x, a_transformBox.hi.x);
    return a_transformBox.size();
  }

  /** \internal */
  template<int DIM>
  inline std::ostream& operator<<(std::ostream& output, const point_t<DIM> p)
  {
    output<<"[";
    for(int i=0; i<DIM-1; i++)
      {
        output<<p.x[i]<<",";
      }
    output<<p.x[DIM-1]<<"]";
    return output;
  }
  
  /** \internal */
  template<int DIM>
  inline std::ostream& operator<<(std::ostream& output, const box_t<DIM>& b)
  {
    output<<"["<<b.lo<<","<<b.hi<<"]";
    return output;
  }

} // namespace fftx


/*!
 * \addtogroup fftx_helper
 * @{
 */
namespace fftx_helper
{
  inline size_t reverseBits(size_t x, int n) {
    size_t result = 0;
    for (int i = 0; i < n; i++, x >>= 1)
      result = (result << 1) | (x & 1U);
    return result;
  }



  inline void multiply(std::complex<double>& a, const std::complex<double>& b){ a*=b;}

  template<int C>
  inline void multiply(std::complex<double>(&a)[C], const std::complex<double>(&b)[C])
  {
    for(int i=0; i<C; i++) { a[i]*=b[i]; }
  }

  inline void assign(std::complex<double>& a, const std::complex<double>& b){ a=b;}

  template<int C>
  inline void assign(std::complex<double>(&a)[C], const std::complex<double>(&b)[C])
  {
    for(int i=0; i<C; i++) { a[i]=b[i]; }
  }
  inline void subtract(std::complex<double>& a, const std::complex<double>& b){ a-=b; }

  template<int C>
  inline void subtract(std::complex<double>(&a)[C], const std::complex<double>(&b)[C])
  {
    for(int i=0; i<C; i++) { a[i]-=b[i]; }
  }
  inline void increment(std::complex<double>& a, const std::complex<double>& b){ a+=b; }

  template<int C>
  inline void increment(std::complex<double>(&a)[C], const std::complex<double>(&b)[C])
  {
    for(int i=0; i<C; i++) { a[i]+=b[i]; }
  }


  template<int BATCH, typename T, int DIR = 1>
  static void batchtransformRadix2(int n, int stride, T* dvec[])

  {  
    static std::vector<std::complex<double>> expTable;
    int levels = 0;  // Compute levels = floor(log2(n))
    for (size_t temp = n; temp > 1U; temp >>= 1)
      {
        levels++;
      }
    if (static_cast<size_t>(1U) << levels != n)
      {
        throw std::domain_error("Length is not a power of 2");
      }
  
    // Trigonometric table
    if (expTable.size() != n/2)
      {
        expTable.resize(n/2);
        // This must be int, not size_t, because we will negate it.
        for (int i = 0; i < n / 2; i++)
          {
            // std::complex<double> k = std::complex<double>(0, -(2*DIR*i)*M_PI/n);
            // std::complex<double> tw = std::exp(k);
            double th = -(2*DIR*i)*M_PI/(n*1.);
            std::complex<double> tw = std::complex<double>(cos(th), sin(th));
            expTable[i] = tw;
          }
      }
    
    // Bit-reversed addressing permutation
    for (size_t i = 0; i < n; i++)
      {
        size_t j = reverseBits(i, levels);
        // If j == i, then no change.
        // If j != i, then swap, but only if j > i, so as not to duplicate.
        if (j > i)
          {
            for(int b=0; b<BATCH; b++)
              {
                std::swap(dvec[b][i*stride], dvec[b][j*stride]);
              }
          }
      }
  
    // Cooley-Tukey decimation-in-time radix-2 FFT.
    // From algorithm iterative-fft in Wikipedia "Cooley-Tukey FFT algorithm"
    for (size_t size = 2; size <= n; size *= 2)
      {
        size_t halfsize = size / 2;
        size_t tablestep = n / size;
        for (size_t k = 0; k < n; k += size)
          {
            for (size_t j = 0; j < halfsize; j++)
              {
                size_t indkj = (k + j)*stride;
                size_t indkjhalfsize = (k + j + halfsize)*stride;
                for (int b=0; b<BATCH; b++)
                  {
                    T* vec = dvec[b];
                    T temp1;
                    assign(temp1, vec[indkjhalfsize]);
                    // OutStream() << "size=" << size << " tablestep=" << tablestep << " : k=" << k << " j=" << j << " j*tablestep = " << (j*tablestep) << "\n";
                    multiply(temp1, expTable[j*tablestep]);
                    T temp2;
                    assign(temp2, vec[indkj]);
                    increment(vec[indkj], temp1);
                    assign(vec[indkjhalfsize], temp2);
                    subtract(vec[indkjhalfsize], temp1);
                  }
                // OutStream() << "k=" << k << " j=" << j << "\n";
              }
          }
        if (size == n)  // Prevent overflow in 'size *= 2'
          {
            break;
          }
      }
  }
} // namespace fftx_helper
/*! @} */

#endif /*  end include guard FFTX_H */
